<HTML>
<HEAD>
<TITLE>clist.h</TITLE>
</HEAD>

<BODY>

<H1>#include "clist.h"</H1>

This page has information from files
<A HREF="../clist.h">clist.h</A> and <A HREF="../clist.c">clist.c</A>.

<H2>Contents</H2>
<UL>
<LI><A HREF="#routines">Public Routines</A>
<LI><A HREF="#defns">Public Definitions</A>
<LI><A HREF="#intro">Introduction</A>
</UL>

<P>
<HR><A NAME=routines></A><H2>Public Routines in File clist.c</H2>
<H4>Index</H4>
<TABLE CELLPADDING=3>
<TR><TD><A HREF="#clauses_in_clist">clauses_in_clist</A></TD><TD><A HREF="#clist_length">clist_length</A></TD><TD><A HREF="#clist_zap">clist_zap</A></TD><TD><A HREF="#neg_clauses_in_clist">neg_clauses_in_clist</A></TD>
</TR>
<TR><TD><A HREF="#clist_append">clist_append</A></TD><TD><A HREF="#clist_member">clist_member</A></TD><TD><A HREF="#copy_clist_to_plist_shallow">copy_clist_to_plist_shallow</A></TD><TD><A HREF="#neg_nonunit_in_clist">neg_nonunit_in_clist</A></TD>
</TR>
<TR><TD><A HREF="#clist_append_all">clist_append_all</A></TD><TD><A HREF="#clist_move_clauses">clist_move_clauses</A></TD><TD><A HREF="#equality_in_clist">equality_in_clist</A></TD><TD><A HREF="#p_clist">p_clist</A></TD>
</TR>
<TR><TD><A HREF="#clist_append_plist">clist_append_plist</A></TD><TD><A HREF="#clist_number_of_weight">clist_number_of_weight</A></TD><TD><A HREF="#fprint_clause_clist">fprint_clause_clist</A></TD><TD><A HREF="#p_clist_mem">p_clist_mem</A></TD>
</TR>
<TR><TD><A HREF="#clist_check">clist_check</A></TD><TD><A HREF="#clist_prepend">clist_prepend</A></TD><TD><A HREF="#fprint_clist">fprint_clist</A></TD><TD><A HREF="#plist_to_clist">plist_to_clist</A></TD>
</TR>
<TR><TD><A HREF="#clist_empty">clist_empty</A></TD><TD><A HREF="#clist_remove">clist_remove</A></TD><TD><A HREF="#fprint_clist_mem">fprint_clist_mem</A></TD><TD><A HREF="#pos_in_clist">pos_in_clist</A></TD>
</TR>
<TR><TD><A HREF="#clist_free">clist_free</A></TD><TD><A HREF="#clist_remove_all">clist_remove_all</A></TD><TD><A HREF="#horn_clist">horn_clist</A></TD><TD><A HREF="#prepend_clist_to_plist">prepend_clist_to_plist</A></TD>
</TR>
<TR><TD><A HREF="#clist_init">clist_init</A></TD><TD><A HREF="#clist_remove_all_clauses">clist_remove_all_clauses</A></TD><TD><A HREF="#max_wt_in_clist">max_wt_in_clist</A></TD><TD><A HREF="#sort_clist_by_id">sort_clist_by_id</A></TD>
</TR>
<TR><TD><A HREF="#clist_insert_after">clist_insert_after</A></TD><TD><A HREF="#clist_reverse">clist_reverse</A></TD><TD><A HREF="#move_clist_to_plist">move_clist_to_plist</A></TD><TD><A HREF="#unit_clist">unit_clist</A></TD>
</TR>
<TR><TD><A HREF="#clist_insert_before">clist_insert_before</A></TD><TD><A HREF="#clist_swap">clist_swap</A></TD><TD><A HREF="#name_clist">name_clist</A></TD><TD></TD>
</TR>
</TABLE>
<H4>Details</H4>
<A NAME="clauses_in_clist"></A><HR><PRE><B>Plist clauses_in_clist(Plist p, <A HREF="clist.html">Clist</A> l);
</B></PRE>Return the intersection of Plist p of clauses and <A HREF="clist.html">Clist</A> c of clauses.
<A NAME="clist_append"></A><HR><PRE><B>void clist_append(Topform c, <A HREF="clist.html">Clist</A> l);
</B></PRE>This routine appends a Topform to a <A HREF="clist.html">Clist</A>.
<A NAME="clist_append_all"></A><HR><PRE><B>void clist_append_all(<A HREF="clist.html">Clist</A> l1, <A HREF="clist.html">Clist</A> l2);
</B></PRE>Append each member of l2 to l1, then zap l2.  Do not refer to l2
after the call.
<A NAME="clist_append_plist"></A><HR><PRE><B>void clist_append_plist(<A HREF="clist.html">Clist</A> lst, Plist clauses);
</B></PRE><A NAME="clist_check"></A><HR><PRE><B>void clist_check(<A HREF="clist.html">Clist</A> l);
</B></PRE>This routine checks the integrity of a <A HREF="clist.html">Clist</A>.  If any errors are
found, a message is sent to stdout.  This is used for debugging.
<A NAME="clist_empty"></A><HR><PRE><B>BOOL clist_empty(<A HREF="clist.html">Clist</A> lst);
</B></PRE>This function checks if a (non-NULL) <A HREF="clist.html">Clist</A> is empty.
<A NAME="clist_free"></A><HR><PRE><B>void clist_free(<A HREF="clist.html">Clist</A> p);
</B></PRE>This routine frees an empty <A HREF="clist.html">Clist</A>.  If the <A HREF="clist.html">Clist</A> is not empty,
nothing happens.
<A NAME="clist_init"></A><HR><PRE><B><A HREF="clist.html">Clist</A> clist_init(char *name);
</B></PRE>This routine allocates and returns an empty <A HREF="clist.html">Clist</A>, which
is a doubly-linked list of pointers to clauses.
You give it a string (any length, which is copied), representing
the name of the list.  If don't wish to name the list, send NULL.
(You can name the list later with <A HREF="#name_clist">name_clist</A>().)
<A NAME="clist_insert_after"></A><HR><PRE><B>void clist_insert_after(Topform c, <A HREF="clist.html">Clist_pos</A> pos);
</B></PRE>This routine inserts a Topform after a given position in a <A HREF="clist.html">Clist</A>.
<A NAME="clist_insert_before"></A><HR><PRE><B>void clist_insert_before(Topform c, <A HREF="clist.html">Clist_pos</A> pos);
</B></PRE>This routine inserts a Topform before a given position in a <A HREF="clist.html">Clist</A>.
<A NAME="clist_length"></A><HR><PRE><B>int clist_length(<A HREF="clist.html">Clist</A> l);
</B></PRE><A NAME="clist_member"></A><HR><PRE><B>int clist_member(Topform c, <A HREF="clist.html">Clist</A> l);
</B></PRE>This Boolean routine checks if a Topform is a member of a <A HREF="clist.html">Clist</A>.
<A NAME="clist_move_clauses"></A><HR><PRE><B>void clist_move_clauses(<A HREF="clist.html">Clist</A> a, <A HREF="clist.html">Clist</A> b);
</B></PRE>Move all clauses from a to the end of b.
<A NAME="clist_number_of_weight"></A><HR><PRE><B>int clist_number_of_weight(<A HREF="clist.html">Clist</A> lst, int weight);
</B></PRE><A NAME="clist_prepend"></A><HR><PRE><B>void clist_prepend(Topform c, <A HREF="clist.html">Clist</A> l);
</B></PRE>This routine inserts a Topform as the first member of a <A HREF="clist.html">Clist</A>.
<A NAME="clist_remove"></A><HR><PRE><B>void clist_remove(Topform c, <A HREF="clist.html">Clist</A> l);
</B></PRE>This routine removes a clause from a <A HREF="clist.html">Clist</A>.  If the Topform occurs
more than once in the <A HREF="clist.html">Clist</A>, the most recently inserted occurrence
is removed.  A fatal error occurs if the Topform is not in the <A HREF="clist.html">Clist</A>.
<A NAME="clist_remove_all"></A><HR><PRE><B>int clist_remove_all(Topform c);
</B></PRE>This routine removes a clause from all lists in which it occurs.
The number of lists from which it was removed is returned.
<A NAME="clist_remove_all_clauses"></A><HR><PRE><B>void clist_remove_all_clauses(<A HREF="clist.html">Clist</A> l);
</B></PRE>This routine removes all clauses from a clist.
The clauses are NOT deleted, even if they occur nowhere else.
<A NAME="clist_reverse"></A><HR><PRE><B>void clist_reverse(<A HREF="clist.html">Clist</A> l);
</B></PRE>Reverse a <A HREF="clist.html">Clist</A>.
<A NAME="clist_swap"></A><HR><PRE><B>void clist_swap(Topform a, Topform b);
</B></PRE>Every clause occurs in a set (maybe empty) of Clists.  Given clauses A and B,
this routine puts A into the lists in which B occurs and vice versa.
<A NAME="clist_zap"></A><HR><PRE><B>void clist_zap(<A HREF="clist.html">Clist</A> l);
</B></PRE>For each Topform (occurrence) in a <A HREF="clist.html">Clist</A>, remove it, and if it occurs
in no other <A HREF="clist.html">Clist</A>, call zap_topform() to delete the clause.
Then, free the <A HREF="clist.html">Clist</A>.
<A NAME="copy_clist_to_plist_shallow"></A><HR><PRE><B>Plist copy_clist_to_plist_shallow(<A HREF="clist.html">Clist</A> a);
</B></PRE><A NAME="equality_in_clist"></A><HR><PRE><B>BOOL equality_in_clist(<A HREF="clist.html">Clist</A> l);
</B></PRE>Does the list contain a clause with a positive equality literal?
<A NAME="fprint_clause_clist"></A><HR><PRE><B>void fprint_clause_clist(FILE *fp, <A HREF="clist.html">Clist</A> lst);
</B></PRE>This routine prints (to FILE *fp) a <A HREF="clist.html">Clist</A> of clauses in standard prefix form.
<A NAME="fprint_clist"></A><HR><PRE><B>void fprint_clist(FILE *fp, <A HREF="clist.html">Clist</A> l);
</B></PRE>This routine prints (to FILE *fp) each clause in a <A HREF="clist.html">Clist</A>.
If the <A HREF="clist.html">Clist</A> has a non-empty name, say "usable", the
string "list(usable).\n" is printed first.
The string "end_of_list.\n" is always printed at the end.
<A NAME="fprint_clist_mem"></A><HR><PRE><B>void fprint_clist_mem(FILE *fp, BOOL heading);
</B></PRE>This routine prints (to FILE *fp) memory usage statistics for data types
associated with the clist package.
The Boolean argument heading tells whether to print a heading on the table.
<A NAME="horn_clist"></A><HR><PRE><B>BOOL horn_clist(<A HREF="clist.html">Clist</A> l);
</B></PRE>Is every clause in the list a Horn clause?
<A NAME="max_wt_in_clist"></A><HR><PRE><B>int max_wt_in_clist(<A HREF="clist.html">Clist</A> l);
</B></PRE>Scan a <A HREF="clist.html">Clist</A>, and return the maximum clause weight seen.
<A NAME="move_clist_to_plist"></A><HR><PRE><B>Plist move_clist_to_plist(<A HREF="clist.html">Clist</A> a);
</B></PRE><A NAME="name_clist"></A><HR><PRE><B>void name_clist(<A HREF="clist.html">Clist</A> p, char *name);
</B></PRE>This routine names or renames a <A HREF="clist.html">Clist</A>.
The string you supply can be any length and is copied.
<A NAME="neg_clauses_in_clist"></A><HR><PRE><B>Plist neg_clauses_in_clist(<A HREF="clist.html">Clist</A> a);
</B></PRE><A NAME="neg_nonunit_in_clist"></A><HR><PRE><B>BOOL neg_nonunit_in_clist(<A HREF="clist.html">Clist</A> l);
</B></PRE>Does the list contain a negative nonunit clause ?
<A NAME="p_clist"></A><HR><PRE><B>void p_clist(<A HREF="clist.html">Clist</A> l);
</B></PRE>This routine prints (to stdout) each clause in a <A HREF="clist.html">Clist</A>.
See <A HREF="#fprint_clist">fprint_clist</A>().
<A NAME="p_clist_mem"></A><HR><PRE><B>void p_clist_mem();
</B></PRE>This routine prints (to stdout) memory usage statistics for data types
associated with the clist package.
<A NAME="plist_to_clist"></A><HR><PRE><B><A HREF="clist.html">Clist</A> plist_to_clist(Plist p, char *name);
</B></PRE><A NAME="pos_in_clist"></A><HR><PRE><B><A HREF="clist.html">Clist_pos</A> pos_in_clist(<A HREF="clist.html">Clist</A> lst, Topform c);
</B></PRE>Return the <A HREF="clist.html">Clist_pos</A> of a Topform in a <A HREF="clist.html">Clist</A>.
<A NAME="prepend_clist_to_plist"></A><HR><PRE><B>Plist prepend_clist_to_plist(Plist p, <A HREF="clist.html">Clist</A> c);
</B></PRE><A NAME="sort_clist_by_id"></A><HR><PRE><B>void sort_clist_by_id(<A HREF="clist.html">Clist</A> lst);
</B></PRE><A NAME="unit_clist"></A><HR><PRE><B>BOOL unit_clist(<A HREF="clist.html">Clist</A> l);
</B></PRE>Is every clause in the list a unit clause?
<HR><A NAME=defns></A><H2>Public Definitions in File clist.h</H2>
<PRE>
typedef struct clist_pos * <A HREF="clist.html">Clist_pos</A>;
typedef struct clist * <A HREF="clist.html">Clist</A>;

struct clist {
  char       *name;
  <A HREF="clist.html">Clist_pos</A>  first, last;
  int        length;
};

struct clist_pos {
  <A HREF="clist.html">Clist_pos</A>  prev, next;  /* previous and next member of <A HREF="clist.html">Clist</A> */
  <A HREF="clist.html">Clist_pos</A>  nocc;        /* next member of containment list */
  <A HREF="clist.html">Clist</A>      list;        /* the head of the list */
  Topform     c;          /* pointer to the clause */
};

</PRE><HR><A NAME=intro></A><H2>Introduction</H2>
This package handles Clists, which are doubly-linked lists of (pointers
to) clauses.  This is the "official" way of building lists of clauses.
(If you need a temporary, singly linked list, you can use Plist instead.)
<P>
An important property of Clists is that each clause knows what Clists
it is on.  In particular, each clause has a (singly linked) list of
containing Clists, constructed from the same nodes as the ordinary Clist
(see the definition of struct clist_pos).

<HR>
</BODY>
</HTML>
